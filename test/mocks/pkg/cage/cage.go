// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/cage/cage.go

// Package cage is a generated GoMock package.
package cage

import (
	gomock "github.com/golang/mock/gomock"
	unix "golang.org/x/sys/unix"
	exec "os/exec"
	reflect "reflect"
)

// MockCage is a mock of Cage interface
type MockCage struct {
	ctrl     *gomock.Controller
	recorder *MockCageMockRecorder
}

// MockCageMockRecorder is the mock recorder for MockCage
type MockCageMockRecorder struct {
	mock *MockCage
}

// NewMockCage creates a new mock instance
func NewMockCage(ctrl *gomock.Controller) *MockCage {
	mock := &MockCage{ctrl: ctrl}
	mock.recorder = &MockCageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockCage) EXPECT() *MockCageMockRecorder {
	return m.recorder
}

// Encage mocks base method
func (m *MockCage) Encage(monster *exec.Cmd) *exec.Cmd {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Encage", monster)
	ret0, _ := ret[0].(*exec.Cmd)
	return ret0
}

// Encage indicates an expected call of Encage
func (mr *MockCageMockRecorder) Encage(monster interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Encage", reflect.TypeOf((*MockCage)(nil).Encage), monster)
}

// Execute mocks base method
func (m *MockCage) Execute() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Execute")
	ret0, _ := ret[0].(error)
	return ret0
}

// Execute indicates an expected call of Execute
func (mr *MockCageMockRecorder) Execute() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Execute", reflect.TypeOf((*MockCage)(nil).Execute))
}

// MockRuntimeForCage is a mock of RuntimeForCage interface
type MockRuntimeForCage struct {
	ctrl     *gomock.Controller
	recorder *MockRuntimeForCageMockRecorder
}

// MockRuntimeForCageMockRecorder is the mock recorder for MockRuntimeForCage
type MockRuntimeForCageMockRecorder struct {
	mock *MockRuntimeForCage
}

// NewMockRuntimeForCage creates a new mock instance
func NewMockRuntimeForCage(ctrl *gomock.Controller) *MockRuntimeForCage {
	mock := &MockRuntimeForCage{ctrl: ctrl}
	mock.recorder = &MockRuntimeForCageMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockRuntimeForCage) EXPECT() *MockRuntimeForCageMockRecorder {
	return m.recorder
}

// Setrlimit mocks base method
func (m *MockRuntimeForCage) Setrlimit(which int, lim *unix.Rlimit) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Setrlimit", which, lim)
	ret0, _ := ret[0].(error)
	return ret0
}

// Setrlimit indicates an expected call of Setrlimit
func (mr *MockRuntimeForCageMockRecorder) Setrlimit(which, lim interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Setrlimit", reflect.TypeOf((*MockRuntimeForCage)(nil).Setrlimit), which, lim)
}

// Exec mocks base method
func (m *MockRuntimeForCage) Exec(argv0 string, argv, envv []string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exec", argv0, argv, envv)
	ret0, _ := ret[0].(error)
	return ret0
}

// Exec indicates an expected call of Exec
func (mr *MockRuntimeForCageMockRecorder) Exec(argv0, argv, envv interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exec", reflect.TypeOf((*MockRuntimeForCage)(nil).Exec), argv0, argv, envv)
}
